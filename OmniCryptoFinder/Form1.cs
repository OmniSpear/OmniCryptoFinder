/*
 * The MIT License (MIT) 
 * Copyright (c) 2013 OmniSpear, Inc. & Jared Armstrong
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 * */


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using NLog;
using System.Threading;


namespace OmniCryptoFinder
{
    public partial class Form1 : Form
    {
        BackgroundWorker runScanBgWorker;
        private Logger logger;

        internal class UserArgs
        {
            internal string path { get; set; }
            internal string delay { get; set; }
        }

        public Form1()
        {
            InitializeComponent();


            logger = LogManager.GetLogger("OCF");

            runScanBgWorker = new BackgroundWorker();
            runScanBgWorker.WorkerReportsProgress = true;
            runScanBgWorker.DoWork += new DoWorkEventHandler(runScanBgWorker_DoWork);
            runScanBgWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(runScanBgWorker_RunWorkerCompleted);
            runScanBgWorker.ProgressChanged += new ProgressChangedEventHandler(runScanBgWorker_ProgressChanged);
            runScanBgWorker.WorkerReportsProgress = true;
            runScanBgWorker.WorkerSupportsCancellation = true;

            button1.Enabled = false;
            button2.Enabled = true;

            this.textBox2.KeyPress += new KeyPressEventHandler(textBox2_KeyPress);

            progressBar1.Hide();

            LinkLabel.Link link = new LinkLabel.Link();
            link.LinkData = "output.csv";
            linkLabel1.Links.Add(link);
            linkLabel1.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(lnkGeneric_LinkClicked);

            MessageBox.Show("OmniSpear, Inc. disclaims to the [fullest] extent authorized by law any and all [other] warranties, whether express or implied, including, without limitation, any implied warranties of [title, non-infringement, integration,] merchantability or fitness for a particular purpose.\n\n" +
"You assume responsibility for selecting the software to achieve your intended results, and for the results obtained from your use of the software. You shall bear the entire risk as to the quality and the performance of the software.\n\n" +
"Without limitation of the foregoing, [Licensor] expressly does not warrant that:\n" +
"(a) the software will meet your requirements [or expectations];\n" +
"(b) the software or the software content] will be free of bugs, errors, viruses or other defects;\n" +
"(c) any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;\n" +
"(d) the software will be compatible with third party software;\n" +
"(e) any errors in the software will be corrected."
            , "Agree to usage terms");

        }

        private void lnkGeneric_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            LinkLabel lnk = new LinkLabel();
            lnk = (LinkLabel)sender;
            lnk.Links[lnk.Links.IndexOf(e.Link)].Visited = true;
            System.Diagnostics.Process.Start(e.Link.LinkData.ToString());
        }

        private void button1_Click(object sender, EventArgs e)
        {

            var args = new UserArgs() { path = this.textBox1.Text, delay = this.textBox2.Text };

            runScanBgWorker.RunWorkerAsync(args);
            button1.Enabled = false;
            button1.Hide();
            progressBar1.Value = 0;
            progressBar1.Show();
            button2.Enabled = false;
        }

        private void textBox2_KeyPress(object sender, KeyPressEventArgs e)
        {
            e.Handled = !char.IsDigit(e.KeyChar);
        }

        private void button2_Click(object sender, EventArgs e)
        {

            DialogResult result = openFileDialog1.ShowDialog();
            if (result == DialogResult.OK)
            {
                button1.Enabled = true;
                this.textBox1.Text = openFileDialog1.SelectedPath;
            }
        }

        private void runScanBgWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            //button1.Enabled = false;
            runScanBgWorker.ReportProgress(0);
            UserArgs args = (UserArgs)e.Argument;

            List<string> files = null;

            try
            {
                files = GetFilesRecursively((string)args.path, "*.*");
            }
            catch (Exception exc)
            {
                logger.Error(exc);
            }

            int delayValue = 0;
            bool result = Int32.TryParse(args.delay, out delayValue);

            var pos = 1;
            using (StreamWriter w = File.AppendText("output.csv"))
            {
                foreach (string file in files)
                {

                    try
                    {
                        runScanBgWorker.ReportProgress((files.Count / pos), file);
                    }
                    catch (Exception exct)
                    {
                        logger.Error(exct);
                    }

                    var checkResult = checkFile(file);
                    if (checkResult == 1)
                    {
                        w.WriteLine("\"{0}\",\"{1}\",\"{2}\"", DateTime.Now.ToLongTimeString(), file, "Valid file format");
                    }
                    else if (checkResult == -1)
                    {
                        w.WriteLine("\"{0}\",\"{1}\",\"{2}\"", DateTime.Now.ToLongTimeString(), file, "Error reading file");
                    }
                    else
                    {
                        w.WriteLine("\"{0}\",\"{1}\",\"{2}\"", DateTime.Now.ToLongTimeString(), file, "May be encrypted");
                    }

                    pos++;


                    if (delayValue != null && delayValue > 0)
                    {
                        Thread.Sleep(delayValue);
                    }
                }
            }

            runScanBgWorker.ReportProgress(100);


            e.Result = true;
            //e.Cancel = true;


        }

        /// <summary>
        /// This function calls itself recursively for each of the subdirectories that it finds
        /// in the root directory passed to it. It returns files of the extension as specified
        /// by the caller.
        /// </summary>
        /// <param name="rootDirectory">The directory from which the file list is sought.</param>
        /// <param name="extension">The particular extension for which the file list is sought.</param>
        /// <returns>A list of all the files with extension as specified by the caller. This list
        /// includes the files in the current directory as well its sub-directories.</returns>
        private List<string> GetFilesRecursively(string rootDirectory, string extension)
        {
            // Uncomment this line only if you want to trace the control as it goes from
            // sub-directory to sub-directory. Be ready for long scrolls of text output:
            //Console.WriteLine ("Currently in directory {0}", rootDirectory);

            // Create an output list:
            List<string> opList = new List<string>();

            try
            {
                // Get all files in the current directory:
                //string[] allFiles = Directory.GetFiles(rootDirectory, "*." + extension);


                opList.AddRange(Directory.EnumerateFiles(rootDirectory));
                // Add these files to the output list:

                // Get all sub-directories in current directory:
                //string[] subDirectories = Directory.EnumerateDirectories(rootDirectory);

                // And iterate through them:
                foreach (string subDir in Directory.EnumerateDirectories(rootDirectory))
                {
                    // Get all the files from the sub-directory:
                    List<string> subDirFileList = GetFilesRecursively(subDir, extension);
                    // And add it to this list:
                    opList.AddRange(subDirFileList);
                }

            }
            catch (Exception exc)
            {
                logger.Error(exc);
            }

            // Finally return the output list:
            return opList;
        }

        private void runScanBgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            if (e.UserState != null)
            {
                toolStripStatusLabel2.Text = e.UserState.ToString();
            }
            //logger.Info("runScanBgWorker %: " + e.ProgressPercentage.ToString());
            progressBar1.Increment(1);

        }

        private void runScanBgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Error is OverflowException)
            {
                logger.Error("**OVERFLOW ERROR, number is too large to be represented by the decimal data type**");
            }

            toolStripStatusLabel2.Text = "Scan Completed successfully";
            button2.Enabled = true;
            button1.Show();
            progressBar1.Hide();

        }

        private string[] getFiles(string p)
        {
            string[] files = Directory.GetFiles(p,
                                                "*.*",
                                                SearchOption.AllDirectories);

            return files;
        }

        private int checkFile(string filename)
        {
            byte[] buffer = new byte[512];
            try
            {
                using (FileStream fs = new FileStream(filename, FileMode.Open, FileAccess.Read))
                {
                    fs.Read(buffer, 0, buffer.Length);
                    fs.Close();
                }
            }
            catch (IOException ex)
            {
                logger.Error(ex.Message);
                return -1;
            }
            catch (System.UnauthorizedAccessException ex)
            {
                logger.Error(ex.Message);
            }

            // Original information found in source documents or http://cpansearch.perl.org/src/EXIFTOOL/Image-ExifTool-9.13/lib/Image/ExifTool.pm 
            var dict = new Dictionary<string, string> {
                { "PDF", "PDF-" } 
                ,{ "JPG", "\xff\xd8\xff" }
                ,{ "JPEG", "\xff\xd8\xff" }
                ,{ "TIFF", "MM" }
                ,{ "TIF", "MM" }
                ,{ "ZIP", "PK" }
                ,{ "BMP", "BM" }
                ,{ "DOCX", "PK" }
                ,{ "XLSX", "PK" }
                ,{ "VSDX", "PK" }
                ,{ "PPTX", "PK" }
                ,{ "XLSM", "PK" }
                ,{ "WAV", "WAVE" }
                ,{ "EXE", "MZ" }
                ,{ "GIF", "GIF" }
                ,{ "DLL", "MZ" }
                ,{ "MSI", "\xfe\xed" }
                ,{ "PNG", "NG\r\n\x1a\n" }
                ,{ "MDB", "Standard Jet DB" }
                ,{ "MPEG", "\0\0\x01" }
                ,{ "MPG", "\0\0\x01" }
                ,{ "MDBX", "PK" }
                ,{ "PSD", "8BPS\0" }
                ,{ "FLV", "FLV\x01" }
                ,{ "RTF", "\\rtf" }
                ,{ "RAR", "Rar!\x1a\x07\0" }
                ,{ "DOC", "\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1" }
                ,{ "XLS", "\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1" }
                ,{ "PPT", "\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1" }
            };

            char[] delimiters = new char[] { '.' };
            var fileExt = filename.Split(delimiters).Last();
            if (dict.ContainsKey(fileExt.ToUpper()))
            {
                //logger.Debug("Found Ext: " + fileExt.ToUpper());
                // From byte array to string
                string s = Encoding.Default.GetString(buffer, 0, buffer.Length);
                if (s.Contains(dict[fileExt.ToUpper()]))
                {
                    return 1;
                }
                else if (fileExt.ToUpper() == "EXE" || fileExt.ToUpper() == "MSI" || fileExt.ToUpper() == "DLL")
                {
                    if (s.Contains("\xca\xfe\xba\xbe") || s.Contains("\xfe\xed\xfa") || s.Contains("\xfa\xed\xfe"))
                    {
                        return 1;
                    }
                }
                else
                {
                    //logger.Debug(fileExt.ToUpper() + ": [" + s + "] !CONT [" + dict[fileExt.ToUpper()] + "]");
                }
            }

            return 0;
        }


        /*
         * PDF = PDF-
         * JPG = Exif
         * PNG = PNG
         * TIFF = MM
         * ZIP / wordDocx = PK
         * CSV
         * DOC = –œ‡°±·
         * XLS = –œ‡°±·
         * PPT = –œ‡°±·
         * MDB = Standard Jet DB
         * MDBX 
         * EXE = MZ
         * WAV = WAVE
         * */

    }
}
